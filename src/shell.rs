/// Shell integration - generates hooks for different shells
use std::fmt;

/// Supported shell types
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum ShellType {
    Zsh,
    // Future: Bash, Fish, PowerShell
}

impl fmt::Display for ShellType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            ShellType::Zsh => write!(f, "zsh"),
        }
    }
}

/// Shell hook generator
pub struct ShellHook {
    shell_type: ShellType,
}

impl ShellHook {
    /// Create a new shell hook generator
    pub fn new(shell_type: ShellType) -> Self {
        Self { shell_type }
    }

    /// Generate the shell hook code
    pub fn generate(&self) -> String {
        match self.shell_type {
            ShellType::Zsh => self.generate_zsh(),
        }
    }

    /// Generate Zsh hook code
    fn generate_zsh(&self) -> String {
        r#"
# Omniscient - Command History Tracker
# Generated by: omniscient init
# Add this to your ~/.zshrc

# Start timer before command execution
_omniscient_preexec() {
    export _OMNISCIENT_START=$EPOCHREALTIME
}

# Capture command after execution
_omniscient_precmd() {
    local exit_code=$?
    local cmd=$(fc -ln -1 | sed 's/^[[:space:]]*//')
    
    if [[ -n "$_OMNISCIENT_START" ]]; then
        local end=$EPOCHREALTIME
        local duration=$(( (end - _OMNISCIENT_START) * 1000 ))
        
        # Run capture in background to avoid blocking shell
        omniscient capture --exit-code "$exit_code" --duration "$duration" "$cmd" &
        
        unset _OMNISCIENT_START
    fi
}

# Register hooks with Zsh
precmd_functions+=(_omniscient_precmd)
preexec_functions+=(_omniscient_preexec)

# Optional: Set up completion (future enhancement)
# autoload -Uz compinit
# compinit
"#
        .to_string()
    }

    /// Get installation instructions for the shell
    pub fn installation_instructions(&self) -> String {
        match self.shell_type {
            ShellType::Zsh => {
                r#"Installation Instructions for Zsh:

1. Run this command to generate the hook:
   omniscient init

2. Add the output to your ~/.zshrc file:
   omniscient init >> ~/.zshrc

3. Reload your shell:
   source ~/.zshrc

4. Start using your shell normally - all commands will be captured automatically!

To verify it's working:
   omniscient stats

Optional: Export your history before setup to preserve existing data.
"#
                .to_string()
            }
        }
    }
}

impl Default for ShellHook {
    fn default() -> Self {
        Self::new(ShellType::Zsh)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_shell_hook_creation() {
        let hook = ShellHook::new(ShellType::Zsh);
        assert_eq!(hook.shell_type, ShellType::Zsh);
    }

    #[test]
    fn test_zsh_hook_generation() {
        let hook = ShellHook::new(ShellType::Zsh);
        let code = hook.generate();

        // Verify essential components are present
        assert!(code.contains("_omniscient_preexec"));
        assert!(code.contains("_omniscient_precmd"));
        assert!(code.contains("EPOCHREALTIME"));
        assert!(code.contains("precmd_functions+="));
        assert!(code.contains("preexec_functions+="));
        assert!(code.contains("omniscient capture"));
        assert!(code.contains("&")); // Background execution
    }

    #[test]
    fn test_hook_has_error_handling() {
        let hook = ShellHook::new(ShellType::Zsh);
        let code = hook.generate();

        // Should check if timer was set
        assert!(code.contains("if [[ -n \"$_OMNISCIENT_START\" ]]"));
        
        // Should clean up timer
        assert!(code.contains("unset _OMNISCIENT_START"));
    }

    #[test]
    fn test_hook_async_execution() {
        let hook = ShellHook::new(ShellType::Zsh);
        let code = hook.generate();

        // Verify async execution (background process)
        assert!(code.contains("&"));
        assert!(code.contains("omniscient capture"));
    }

    #[test]
    fn test_installation_instructions() {
        let hook = ShellHook::new(ShellType::Zsh);
        let instructions = hook.installation_instructions();

        assert!(instructions.contains("omniscient init"));
        assert!(instructions.contains("~/.zshrc"));
        assert!(instructions.contains("source"));
    }

    #[test]
    fn test_shell_type_display() {
        assert_eq!(ShellType::Zsh.to_string(), "zsh");
    }

    #[test]
    fn test_default_shell_hook() {
        let hook = ShellHook::default();
        assert_eq!(hook.shell_type, ShellType::Zsh);
    }

    #[test]
    fn test_hook_captures_all_required_data() {
        let hook = ShellHook::new(ShellType::Zsh);
        let code = hook.generate();

        // Verify all required data is captured
        assert!(code.contains("exit_code")); // Exit code
        assert!(code.contains("duration")); // Duration
        assert!(code.contains("cmd")); // Command text
        assert!(code.contains("--exit-code"));
        assert!(code.contains("--duration"));
    }
}