use crate::Result;
/// Shell integration - generates hooks for different shells
use std::fmt;

/// Supported shell types
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum ShellType {
    Zsh,
    Bash,
    // Future: Fish, PowerShell
}

impl fmt::Display for ShellType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            ShellType::Zsh => write!(f, "zsh"),
            ShellType::Bash => write!(f, "bash"),
        }
    }
}

/// Shell hook generator
pub struct ShellHook {
    shell_type: ShellType,
}

impl ShellHook {
    /// Create a new shell hook generator
    pub fn new(shell_type: ShellType) -> Self {
        Self { shell_type }
    }

    /// Generate the shell hook code
    pub fn generate(&self) -> String {
        match self.shell_type {
            ShellType::Zsh => self.generate_zsh(),
            ShellType::Bash => self.generate_bash(),
        }
    }

    /// Generate Zsh hook code
    fn generate_zsh(&self) -> String {
        r#"
# Omniscient - Command History Tracker
# Generated by: omniscient init
# Add this to your ~/.zshrc

# Start timer before command execution
_omniscient_preexec() {
    export _OMNISCIENT_START=$EPOCHREALTIME
}

# Capture command after execution
_omniscient_precmd() {
    local exit_code=$?
    local cmd=$(fc -ln -1 | sed 's/^[[:space:]]*//')
    
    if [[ -n "$_OMNISCIENT_START" ]]; then
        local end=$EPOCHREALTIME
        local duration=$(( int((end - _OMNISCIENT_START) * 1000) ))

        # Run capture in background to avoid blocking shell
        # Redirect output and disown to prevent job notifications
        omniscient capture --exit-code "$exit_code" --duration "$duration" "$cmd" &>/dev/null &!

        unset _OMNISCIENT_START
    fi
}

# Register hooks with Zsh
precmd_functions+=(_omniscient_precmd)
preexec_functions+=(_omniscient_preexec)

# Optional: Set up completion (future enhancement)
# autoload -Uz compinit
# compinit
"#
        .to_string()
    }

    /// Generate Bash hook code
    fn generate_bash(&self) -> String {
        r#"
# Omniscient - Command History Tracker
# Generated by: omniscient init
# Add this to your ~/.bashrc (Linux) or ~/.bash_profile (macOS)

# NOTE: Requires bash-preexec library
# Install with:
# curl -sSL https://github.com/rcaloras/bash-preexec/raw/master/bash-preexec.sh -o ~/.bash-preexec.sh
# Then add to your bash profile: source ~/.bash-preexec.sh

# Start timer before command execution
_omniscient_preexec() {
    _OMNISCIENT_START=$(date +%s%N)
}

# Capture command after execution
_omniscient_precmd() {
    local exit_code=$?
    local cmd=$(history 1 | sed 's/^[ ]*[0-9]*[ ]*//')

    if [[ -n "$_OMNISCIENT_START" ]]; then
        local end=$(date +%s%N)
        local duration=$(( (end - _OMNISCIENT_START) / 1000000 ))

        # Run capture in background to avoid blocking shell
        # Redirect output and disown to prevent job notifications
        omniscient capture --exit-code "$exit_code" --duration "$duration" "$cmd" &>/dev/null &
        disown

        unset _OMNISCIENT_START
    fi
}

# Register hooks with bash-preexec
preexec_functions+=(_omniscient_preexec)
precmd_functions+=(_omniscient_precmd)
"#
        .to_string()
    }

    /// Auto-detect the current shell
    pub fn detect_shell() -> Result<ShellType> {
        // Check $SHELL environment variable
        if let Ok(shell) = std::env::var("SHELL") {
            if shell.contains("zsh") {
                return Ok(ShellType::Zsh);
            } else if shell.contains("bash") {
                return Ok(ShellType::Bash);
            }
        }

        // Default to Zsh if detection fails
        Ok(ShellType::Zsh)
    }

    /// Get installation instructions for the shell
    pub fn installation_instructions(&self) -> String {
        match self.shell_type {
            ShellType::Zsh => {
                r#"Installation Instructions for Zsh:

1. Run this command to generate the hook:
   omniscient init

2. Add the output to your ~/.zshrc file:
   omniscient init >> ~/.zshrc

3. Reload your shell:
   source ~/.zshrc

4. Start using your shell normally - all commands will be captured automatically!

To verify it's working:
   omniscient stats

Optional: Export your history before setup to preserve existing data.
"#
                .to_string()
            }
            ShellType::Bash => {
                r#"Installation Instructions for Bash:

1. Install bash-preexec (required dependency):
   curl -sSL https://github.com/rcaloras/bash-preexec/raw/master/bash-preexec.sh -o ~/.bash-preexec.sh

2. Add bash-preexec to your shell profile:
   # For Linux (add to ~/.bashrc):
   echo 'source ~/.bash-preexec.sh' >> ~/.bashrc

   # For macOS (add to ~/.bash_profile):
   echo 'source ~/.bash-preexec.sh' >> ~/.bash_profile

3. Generate and add Omniscient hook:
   # For Linux:
   omniscient init --shell bash >> ~/.bashrc

   # For macOS:
   omniscient init --shell bash >> ~/.bash_profile

4. Reload your shell:
   # For Linux:
   source ~/.bashrc

   # For macOS:
   source ~/.bash_profile

5. Start using your shell normally - all commands will be captured automatically!

To verify it's working:
   omniscient stats

Optional: Export your history before setup to preserve existing data.
"#
                .to_string()
            }
        }
    }
}

impl Default for ShellHook {
    fn default() -> Self {
        Self::new(ShellType::Zsh)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_shell_hook_creation() {
        let hook = ShellHook::new(ShellType::Zsh);
        assert_eq!(hook.shell_type, ShellType::Zsh);
    }

    #[test]
    fn test_zsh_hook_generation() {
        let hook = ShellHook::new(ShellType::Zsh);
        let code = hook.generate();

        // Verify essential components are present
        assert!(code.contains("_omniscient_preexec"));
        assert!(code.contains("_omniscient_precmd"));
        assert!(code.contains("EPOCHREALTIME"));
        assert!(code.contains("precmd_functions+="));
        assert!(code.contains("preexec_functions+="));
        assert!(code.contains("omniscient capture"));
        assert!(code.contains("&")); // Background execution
    }

    #[test]
    fn test_hook_has_error_handling() {
        let hook = ShellHook::new(ShellType::Zsh);
        let code = hook.generate();

        // Should check if timer was set
        assert!(code.contains("if [[ -n \"$_OMNISCIENT_START\" ]]"));

        // Should clean up timer
        assert!(code.contains("unset _OMNISCIENT_START"));
    }

    #[test]
    fn test_hook_async_execution() {
        let hook = ShellHook::new(ShellType::Zsh);
        let code = hook.generate();

        // Verify async execution (background process)
        assert!(code.contains("&"));
        assert!(code.contains("omniscient capture"));
    }

    #[test]
    fn test_installation_instructions() {
        let hook = ShellHook::new(ShellType::Zsh);
        let instructions = hook.installation_instructions();

        assert!(instructions.contains("omniscient init"));
        assert!(instructions.contains("~/.zshrc"));
        assert!(instructions.contains("source"));
    }

    #[test]
    fn test_shell_type_display() {
        assert_eq!(ShellType::Zsh.to_string(), "zsh");
        assert_eq!(ShellType::Bash.to_string(), "bash");
    }

    #[test]
    fn test_default_shell_hook() {
        let hook = ShellHook::default();
        assert_eq!(hook.shell_type, ShellType::Zsh);
    }

    // Bash-specific tests
    #[test]
    fn test_bash_hook_creation() {
        let hook = ShellHook::new(ShellType::Bash);
        assert_eq!(hook.shell_type, ShellType::Bash);
    }

    #[test]
    fn test_bash_hook_generation() {
        let hook = ShellHook::new(ShellType::Bash);
        let code = hook.generate();

        // Verify essential components are present
        assert!(code.contains("_omniscient_preexec"));
        assert!(code.contains("_omniscient_precmd"));
        assert!(code.contains("date +%s%N")); // Bash timing
        assert!(code.contains("history 1")); // Bash command extraction
        assert!(code.contains("preexec_functions+="));
        assert!(code.contains("precmd_functions+="));
        assert!(code.contains("omniscient capture"));
        assert!(code.contains("&")); // Background execution
        assert!(code.contains("disown")); // Bash disown
    }

    #[test]
    fn test_bash_hook_has_bash_preexec_note() {
        let hook = ShellHook::new(ShellType::Bash);
        let code = hook.generate();

        // Should mention bash-preexec dependency
        assert!(code.contains("bash-preexec"));
    }

    #[test]
    fn test_bash_hook_has_error_handling() {
        let hook = ShellHook::new(ShellType::Bash);
        let code = hook.generate();

        // Should check if timer was set
        assert!(code.contains("if [[ -n \"$_OMNISCIENT_START\" ]]"));

        // Should clean up timer
        assert!(code.contains("unset _OMNISCIENT_START"));
    }

    #[test]
    fn test_bash_installation_instructions() {
        let hook = ShellHook::new(ShellType::Bash);
        let instructions = hook.installation_instructions();

        assert!(instructions.contains("bash-preexec"));
        assert!(instructions.contains("~/.bashrc"));
        assert!(instructions.contains("~/.bash_profile"));
        assert!(instructions.contains("omniscient init --shell bash"));
        assert!(instructions.contains("source"));
    }

    #[test]
    fn test_bash_hook_captures_all_required_data() {
        let hook = ShellHook::new(ShellType::Bash);
        let code = hook.generate();

        // Verify all required data is captured
        assert!(code.contains("exit_code")); // Exit code
        assert!(code.contains("duration")); // Duration
        assert!(code.contains("cmd")); // Command text
        assert!(code.contains("--exit-code"));
        assert!(code.contains("--duration"));
    }

    #[test]
    fn test_hook_captures_all_required_data() {
        let hook = ShellHook::new(ShellType::Zsh);
        let code = hook.generate();

        // Verify all required data is captured
        assert!(code.contains("exit_code")); // Exit code
        assert!(code.contains("duration")); // Duration
        assert!(code.contains("cmd")); // Command text
        assert!(code.contains("--exit-code"));
        assert!(code.contains("--duration"));
    }
}
